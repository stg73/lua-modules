*lua-modules.jax*                    Nvim
                                                                *lua-modules*

                             LUA REFERENCE MANUAL


Type |gO| to see the table of contents.

==============================================================================
導入                                                       *lua-modules-intro*

neovim用のluaモジュール群
|vim_keymap_get.get()| 以外の全ての関数はカリー化されている

==============================================================================
文字列と文字列の対応                                 *lua-lib-character_table*

半角と全角、ローマ字と平仮名、など文字列の対応を集めたもの
例えば `{{"あ","ア"},{"い","イ"}}` のようなもの

==============================================================================
カスタムURLスキームを作る                           *lua-lib-create_urlscheme*

カスタムURLスキームを作ってneovim内で使えるようにする
`init()` でスキームを扱うautocmdを作り `add()` でスキームの定義をする
例
>lua
    create_urlscheme.init()
    create_urlscheme.add({
        https = open_webpage.open,
        http = open_webpage.open,
        github = open_github.open,
    })
<
    上を実行後に `https://example.com` というバッファを開くと
>lua
    open_webpage.open("example.com")
<
    が実行され https://example.com が閲覧できる

create_urlscheme.schemes                          *create_urlscheme.schemes()*
    スキームの定義

create_urlscheme.init()                              *create_urlscheme.init()*
    オートコマンドの作成

create_urlscheme.add({tbl})                           *create_urlscheme.add()*
    スキームと実行する関数を設定する
    キーがスキーム 値が実行される関数

==============================================================================
文字を置換するコマンドを作る               *lua-lib-create_substitute_command*

create_substitute_command.create({cmdname})({tbl})
                                          *create_substitute_command.create()*

    character_table を使って文字列を置換するユーザコマンドを作る
    例
>lua
        local s = require("create_substitute_command")
        local c = require("character_table")

        s.create("Katakana")(c.Hiragana_Katakana)
        s.create_reverse("Hiragana")(c.Hiragana_Katakana)
<
    上では指定した範囲の平仮名を片仮名にするコマンド"Katakana"と
    片仮名を平仮名にするコマンド"Hiragana"を作っている

==============================================================================
githubのファイルを閲覧                                   *lua-lib-open_github*

githubからファイルをダウンロードして閲覧する open_webpageのラッパー

open_github.get_url.tbl({tbl})                     *open_github.get_url.tbl()*
    テーブルを渡す
    例
>lua
        open_github.get_url.tbl({
            repo = "stg73/lua-modules",
            commit = "main",
            file = "readme.txt"
        })
<

open_github.get_url.str({str})                     *open_github.get_url.url()*
    {str} はURLっぽい文字列
    {str} のBNF
>
        <str> ::= <repo> "\" <commit> path | <repo> path
        <repo> ::= user "/" repo "/"
        <commit> ::= "b" branch | "c" commit | "t" tag
<
    ブランチ コミットID タグ が指定できる
    例
        "neovim/neovim/\bmaster/README.md"
        "neovim/neovim/\tv0.11.5/README.md"
        "neovim/neovim/\cb80d390/README.md"
        "neovim/neovim/README.md"
>lua
        open_github.get_url.url("stg73/lua-modules/\\bmain/readme.txt")
        == "github.com/stg73/lua-modules/raw/refs/heads/main/readme.txt"
<

open_github.open({tbl_or_str})                            *open_github.open()*
    引数がテーブルであれば |open_github.get_url.tbl()| 文字列であれば
    |open_github.get_url.url()| に渡し 返り値を |open_webpage.open()| に渡す
>lua
        open_github.open("stg73/lua-modules/doc/lua-modules.jax")
<

==============================================================================
ウェブページを閲覧する                                  *lua-lib-open_webpage*

ウェブページをダウンロードしてneovimで閲覧する
powershellが必要

open_webpage.open({str})                                 *open_webpage.open()*
    ウェブページを閲覧する
    {str} はURLの"https?://"を除いた部分
    パスを元にファイルタイプをセットする
    https://example.com を閲覧するには
>lua
        open_webpage.open("example.com")
<

==============================================================================
パッケージマネージャー                               *lua-lib-package_manager*

パッケージマネージャー

package_manager.directory({dir})                 *package_manager.directory()*
    パッケージを管理するディレクトリを設定する
    以下を含むテーブルを返す

load({name})                              *package_manager.directory().load()*
    {name} のパッケージを ロードする

load_opt({opt})({name})               *package_manager.directory().load_opt()*
    {name} のパッケージを {opt} のタイミングで ロードする
    {opt} には以下が利用できる
    event
        そのイベントがトリガーされたとき
    filetype
        そのファイルタイプがセットされたとき
    [nticvo]map
        そのキーが押されたとき
    now
        真の場合 すぐに読み込む

    さらに {opt} には実行する関数を指定できる
    setup
        すぐに実行される
    config
        ロードされた後に実行される

load_table({opts})                 *package_manager.directory().load_table()*
    `load_opt()` の {opts} を含むテーブルをとる
    テーブルのキーが `load_opt()` の {name} として使用される
    例
>lua
        p = package_manager.directory("c:/users/user/package")
        p.load_table({
            ["vimdoc-ja"] = { event = "CmdLineEnter" },
            ["jumpcursor.vim"] = {
                nmap = "<Plug>(jumpcursor-jump)",
                setup = function()
                    vim.keymap.set('n','<leader>j','<Plug>(jumpcursor-jump)')
                end,
            },
        })
<

available_packages            *package_manager.directory().available_packages*
    インストールされているパッケージ

install({name})({pkg})                 *package_manager.directory().install()*
    {name} という名前で {pkg} をインストールする
    {name} が文字列でなれれば {pkg} から決定される

install_table({pkgs})            *package_manager.directory().install_table()*
    {pkg} を含むテーブルをとる
    テーブルのキーが `install()` の {name} として使用される
    例
>lua
        local p = package_manager.directory("/packages/directory")
        p.install_table({
            { repo = "stg73/lua-modules", branch = "main" },
            hoge = { repo = "https://example.com/hoge.git", tag = "v0.0.1" },
            fuga = "https://example.com/fuga.git",
        })
<

is_installed({pkg})               *package_manager.directory().is_installed()*
    {pkg} がインストールされているかを返す

uninstall({name})                    *package_manager.directory().uninstall()*
    {name} のパッケージをアンインストールする

update({name})                          *package_manager.directory().update()*
    {name} のパッケージをアップデートする

==============================================================================
正規表現                                                       *lua-lib-regex*

vimの正規表現を使って文字列を操作する
バックスラッシュの代わりにスラッシュを使う

regex.convert({str})                                         *regex.convert()*
    スラッシュを使った正規表現をvimの正規表現に変更
    以下の関数で使用されている

regex.find({pattern})({str})                                    *regex.find()*
    |vim.regex| のラッパー
    |string.find()| の |vim.regex| 版
    |string.sub()| で使いやすいようにインデックスも変更

regex.match({pattern})({str})                                  *regex.match()*
    |string.match()| の |vim.regex| 版

regex.has({pattern})({str})                                      *regex.has()*
    パターンが含まれているかどうか

regex.is({pattern})({str})                                        *regex.is()*
    パターンに完全一致するか
    |regex.has()| のラッパー

regex.substitute({sub})({pattern})({str})                 *regex.substitute()*
    |substitute()| のラッパー
    subの関数にはテーブルが渡される

regex.gsub({sub})({pattern})({str})                             *regex.gsub()*
    |string.gsub()| のvim regex版
    |substitute()| のラッパー
    {sub} の関数には文字列が渡される

regex.remove({pattern})({str})                                *regex.remove()*
    |regex.gsub()| のラッパー
>lua
    regex.remove = regex.gsub("")
<

regex.filter({cond})({str})                                   *regex.filter()*
    文字か関数で文字列をフィルターする

regex.gmatch({pattern})({str})                                *regex.gmatch()*
    {str} を {pattern} にマッチする部分に分解したテーブルを返す

regex.split({pattern})({str})                                  *regex.split()*
    文字列を特定の文字で分割する
    |regex.gamtch()| のラッパー

regex.concat({pattern})({str})                                *regex.concat()*
    |vim.fs.joinpath()| を一般化したようなもの

regex.sub({sub})({pattern})({str})                               *regex.sub()*
    |string.gsub()| の |vim.regex| 版
    非推奨

    |regex.gsub()| と違い |substitute()| が使われていない
    非推奨な理由
        |regex.gsub()| より遅い
        |regex.gsub()| と違い"\1"系が使えない
        マッチした部分を削除して再帰しているため ".@<=."のように後読みする場合
        |regex.gsub()| と挙動が異なる
>lua
            regex.gsub(":")(".@<=.")("123") == "1::"
            regex.sub(":")(".@<=.")("123") == "1:3"
<

==============================================================================
ローマ字を扱う                                                *lua-lib-romaji*

ローマ字と仮名の `regex` で使うためのパターンを提供する

romaji.romaji                                                  *romaji.romaji*
    ローマ字のパターン 促音は";"

    ローマ字を平仮名に変換する関数は
>lua
    regex.gsub(tbl.fn(character_table.Romaji_Hiragana))(romaji.romaji)
<

romaji.romaji_rennzoku                                *romaji.romaji_rennzoku*
    ローマ字のパターン 促音は子音の連続 "tta" など

romaji.kana                                                      *romaji.kana*
    平仮名のパターン

==============================================================================
SKK辞書を編集する                                       *lua-lib-skk_commands*

SKKを編集するためのコマンド
`vim.api.nvim_create_user_command` の引数として与える関数を提供する

skk_commands.annotate({opts})                         *skk_commands.annotate()*
    任意の範囲に分類注釈を追加するコマンド
    例
>lua
        vim.api.nvim_create_user_command("SkkAnnotate",
        skk_commands.annotate,
        {bar = true,range = "%"})
<

==============================================================================
SKKを解析する                                                    *lua-lib-skk*

構文解析したり バッファからSKKを読み込んで変換をしたりする

skk.parse.line({str})                                       *skk.parse.line()*
    一行のSKKを構文解析する

skk.hennkann                                                    *skk.hennkann*
    SKK辞書を使い文字列の変換をする

skk.hennkann.fn.buf({buf})({midasi})                   *skk.hennkann.fn.buf()*
    {buf} のバッファからSKKを読み込んで {midasi} を変換する
    複数の候補のテーブルを返す

skk.hennkann.fn.buf_reverse({buf})({kouho})    *skk.hennkann.fn.buf_reverse()*
    {buf} のバッファからSKKを読み込んで {kouho} を変換する
    一つの見出しの文字列を返す

==============================================================================
文字列を楽に扱う                                        *lua-lib-string_utils*

文字列を操作するためのユーティリティ

string_utils.get                                            *string_utils.get*
文字列からなんらかの要素を取得する

string_utils.get.original_name_of_backup_file({path})
                             *string_utils.get.original_name_of_backup_file()*
    拡張子を付け足すタイプのバックアップファイル名から元のファイル名を取得
    "hoge.txt.hoge" -> "hoge.txt"
    "hoge.txt.20251027T124207Z.hoge" -> "hoge.txt"
    例 バックアップファイルのファイルタイプをセットする
>lua
    vim.filetype.add({
        extension = {
            bak = function(path,bufnr)
                return vim.filetype.match({
                    filename = string_utils.get.original_name_of_backup_file(path),
                    buf = bufnr,
                })
            end
        }
    }
<

string_utils.get.path_of_url({url})           *string_utils.get.path_of_url()*
    URLからパスを取得する
    |open_webpage.open()| で使われている

string_utils.remove                                      *string_utils.remove*
文字列を削除する

string_utils.remove.ansi_escape_code({str})
                                      *string_utils.remove.ansi_escape_code()*
    ANSI escape codeを削除する

string_utils.remove.trailing_space({str})
                                        *string_utils.remove.trailing_space()*
行の末尾の空白や末尾の空行を削除する

==============================================================================
いろいろ                                                         *lua-lib-tbl*

テーブルという名前だが 雑多

tbl.compose({fn_tbl})                                          *tbl.compose()*
    関数合成する

tbl.curry2({fn})                                                *tbl.curry2()*
    2変数関数をカリー化する
>lua
    tbl.curry2(table.concat)(tbl)(str) == table.concat(tbl,str)
<

tbl.curry3({fn})                                                *tbl.curry3()*
    3変数関数をカリー化する

tbl.curry4({fn})                                                *tbl.curry4()*
    4変数関数をカリー化する

tbl.filter({pre})({tbl})                                        *tbl.filter()*
    {pre} を条件として {tbl} をフィルターする

tbl.flip({fn})                                                    *tbl.flip()*

tbl.fold({fn})({tbl})                                             *tbl.fold()*
    fold

tbl.get({key})({tbl})                                              *tbl.get()*
>lua
    tbl.get(x)(tbl) == tbl[x]
<

tbl.map({fn})({tbl})                                               *tbl.map()*
    map

tbl.map_reverse({fn_tbl})({x})                             *tbl.map_reverse()*
>lua
    tbl.map_reverse(tbl)(x) == tbl.map(function(fn) return fn(x) end)(tbl)
<

tbl.match({pre})({tbl})                                          *tbl.match()*
    {tbl} の中から {pre} に合致するものを取得する 合致するものがなければ
    nilを返す

tbl.pipe({tbl})                                                   *tbl.pipe()*
    シェルのパイプのように関数の返り値を繋いでいく

==============================================================================
キーマップを取得する                                  *lua-lib-vim_keymap_get*

`vim.keymap.get` に相当する関数を提供する

vim_keymap_get.get({mode},{lhs})                        *vim_keymap_get.get()*
    {mode} における {lhs} のマッピングを取得                *vim.keymap.get()*
    {mode} が空文字列の場合 すべてのモードのマッピングから一つ取得する
>lua
    -- vim.keymap に機能を追加
    vim.keymap.get = vim_keymap_get.get
<

vim_keymap_get.get_string({mode},{lhs})          *vim_keymap_get.get_string()*
    上の関数と機能はほぼ同じだが 関数のマッピングには使えない
    上は |nvim_get_keymap| を使っているのに対し こちらは |:map| を使っている

------------------------------------------------------------------------------
 vi:tw=78:ts=4:ft=help:norl:et
